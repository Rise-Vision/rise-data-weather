<!doctype html>

<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <script src="../../node_modules/@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>
  <script src="../../node_modules/@polymer/test-fixture/test-fixture.js"></script>
  <script src="../../node_modules/mocha/mocha.js"></script>
  <script src="../../node_modules/chai/chai.js"></script>
  <script src="../../node_modules/wct-mocha/wct-mocha.js"></script>
  <script src="../../node_modules/sinon/pkg/sinon.js"></script>

  <script type="text/javascript">
    RisePlayerConfiguration = {
      isConfigured: () => false,
      getDisplayId: () => "ABC123",
      DisplayData: {
        onDisplayAddress: sinon.stub()
      },
    };
  </script>
  <script src="../../src/rise-data-weather-config.js" type="module"></script>
  <script src="../../src/rise-data-weather.js" type="module"></script>
  <script src="../../src/logger.js" type="module"></script>
  <script src="../../src/cache.js" type="module"></script>

</head>
<body>
<test-fixture id="test-block">
  <template>
    <rise-data-weather></rise-data-weather>
  </template>
</test-fixture>

<script type="module">
  import * as loggerModule from '../../src/logger.js';
  import * as cacheModule from '../../src/cache.js';

  let logger = loggerModule.logger;
  let cache = cacheModule.cache;

  suite("rise-data-weather", () => {
    let sandbox = sinon.createSandbox();
    let clock = sandbox.useFakeTimers();
    let element;

    setup(() => {
      sandbox.stub(logger, "init");
      sandbox.stub(logger, "log");

      element = fixture("test-block");
    });

    teardown(()=>{
      sandbox.restore();
    });

    suite( "Properties", () => {

      test( "should set scale", () => {
        assert.equal( element.scale, "F" );
      } );

      test( "should set displayAddress ", () => {
        assert.deepEqual( element.displayAddress, { city: "Toronto", province: "ON", country: "CA"} );
      } );

      test( "should set fullAddress", () => {
        assert.equal( element.fullAddress, "Toronto,ON,CA" );
      } );

      test( "should set displayId", () => {
        assert.equal( element.displayId, "preview" );
      } );

    } );

    suite( "_computeFullAddress", () => {

      test( "should return city,province,country", () => {
        assert.equal(element._computeFullAddress( { city: "Toronto", province: "ON", country: "CA"} ), "Toronto,ON,CA");
        assert.equal(element._computeFullAddress( { city: "Santos", province: "SP", country: "BR"} ), "Santos,SP,BR");
      });

      test( "should skip non-provided values", () => {
        assert.equal(element._computeFullAddress( { city: "Toronto", country: "CA"} ), "Toronto,CA");
        assert.equal(element._computeFullAddress( { province: "SP", country: "BR"} ), "SP,BR");
        assert.equal(element._computeFullAddress( { province: "SP"} ), "SP");
      });

      test( "should return empty string if arguments are not provided", () => {
        assert.equal(element._computeFullAddress( undefined ), "");
        assert.equal(element._computeFullAddress( {} ), "");
      });

      test( "should ignore other fields", () => {
        assert.equal(element._computeFullAddress( { street: "Street", city: "Toronto", province: "ON", country: "CA"} ), "Toronto,ON,CA");
      });
    } );

   
    suite( "ready", () => {
      let stub;

      setup(()=>{
        stub = sinon.stub( window, "addEventListener" );
      });

      teardown(()=>{
        stub.restore();
      });

      test( "should listen for rise-components-ready and call init", () => {
        element.ready();
        assert.isTrue( stub.calledWith('rise-components-ready') );
      });

      test( "should call _init() if  RisePlayerConfiguration is configured", () => {
        sinon.stub( element, '_init');

        RisePlayerConfiguration.isConfigured = () => true ;
        element.ready();
        
        assert.isTrue( element._init.calledOnce );
        assert.isFalse( stub.calledOnce );

        element._init.restore();
      });
    });

    suite( "init", () => {
      test( "should set DisplayId", () => {
        element._init();
        assert.equal(element.displayId, "ABC123");
      });

      test( "should listen for start' event", () => {
        sinon.stub(element, "addEventListener");

        element._init();
        assert.isTrue(element.addEventListener.calledWith( "start" ));

        element.addEventListener.restore();
      });

      test( "should raise 'configured' event", () => {
        sinon.stub(element, "dispatchEvent");

        element._init();
        assert.equal(element.dispatchEvent.getCall(0).args[0].type, "configured");

        element.dispatchEvent.restore();
      });
    });

    suite( "'start' event", () => {
      const validXmlData = "<report><observation temperature=\"12\"/><location/></report>";
      let response;

      setup(()=>{
        response = new Response(validXmlData,{headers:{date: new Date()}});
        sinon.stub(window, "fetch");
      });

      teardown(()=>{
        window.fetch.restore();
      });

      test( "should retrieve displayAddress", () => {
        element.dispatchEvent( new CustomEvent( "start" ) );

        assert.isTrue( RisePlayerConfiguration.DisplayData.onDisplayAddress.called );
      } );

      test( "should update displayAddress", () => {
        RisePlayerConfiguration.DisplayData.onDisplayAddress.returns(callback => {
          callback({
            city: "New York",
            province: "NY",
            country: "US"
          });
        });

        element.dispatchEvent( new CustomEvent( "start" ) );

        assert.deepEqual( element.displayAddress, { city: "New York", province: "NY", country: "US"} );
      });

      // test( "should raise 'request-error' on request failures", done => {
      //   window.fetch.rejects("dsa");
      // 
      //   sandbox.stub(cache, "get").rejects();
      // 
      //   element.addEventListener("request-error", evt => {
      //     assert.isTrue(true);
      // 
      //     done();
      //   });
      // 
      //   element.dispatchEvent( new CustomEvent( "start" ) );
      // });
      
      // test( "should raise 'data-error' on invalid data", done => {
      //   window.fetch.resolves(new Response("<invalid/>",{headers:{date: new Date()}}));
      // 
      //   const cache = { match: sinon.stub().resolves(null) };
      //   sinon.stub(caches, "open").resolves(cache);      
      // 
      //   element.addEventListener("data-error", evt => {
      //     assert.isTrue(true);
      // 
      //     caches.open.restore();
      //     done();
      //   });
      // 
      //   element.dispatchEvent( new CustomEvent( "start" ) );
      // });

      // test( "should make a request and send data-update", done => {
      //   sandbox.stub(cache, "get").rejects();
      //   sandbox.stub(cache, "put").resolves();
      // 
      //   element.addEventListener("data-update", () => {
      //     assert.isTrue(true);
      //     done();
      //   });
      // 
      //   element.dispatchEvent( new CustomEvent( "start" ) );
      // });
      // 
      // test( "should cache requests", done => {
      //   sandbox.stub(cache, "get").rejects();
      //   sandbox.spy(cache, "put", (url, resp)=> {
      //     assert.strictEqual(resp,response);
      // 
      //     done();
      //   });
      // 
      //   element.dispatchEvent( new CustomEvent( "start" ) );
      // });

    });

  });
</script>

</body>
</html>
